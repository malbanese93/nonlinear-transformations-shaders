// Specify which are the functions executed by GPU from outside
#pragma kernel Twist

// Same as in CPU
struct VertexData {
	float3 pos;
	float3 normal;
};

// Define the # of threads in a thread block
#define groupSize 512

// GLOBAL MEMORY buffer for all vertex data
RWStructuredBuffer<VertexData> g_buffer;

// SHARED MEMORY (inside each block) to accelerate computations
groupshared VertexData shared_buffer[groupSize];

// Parameters for transformation
float alpha;
uint vertexCount;

// Specify organization of thread block
// Since there is no implied geometry on the problem solved, we just consider
// each vertex in a single 1D list
// NB: the number of threads is highly dependent on the underlying architecture!
[numthreads(groupSize,1,1)]
void Twist (uint3 threadInGroupIndex : SV_GROUPTHREADID,
	        uint3 groupIndex         : SV_GROUPID)
{
	// Compute global and local thread ID
	// NB: all data stored in 1D so get first component only
	uint g_tid = (groupIndex * groupSize + threadInGroupIndex).x;
	uint l_tid = threadInGroupIndex.x;

	// Apply calculation only where the data actually are!
	if( g_tid < vertexCount ) {
		// First of all, let's copy data from global to shared memory
		shared_buffer[l_tid] = g_buffer[g_tid];

		// Wait until all copies have finished
		GroupMemoryBarrierWithGroupSync();

		// Apply calculation
		float3 v = shared_buffer[l_tid].pos;
		float3 n = shared_buffer[l_tid].normal;

		float theta = alpha * v.z;
		float dtheta = alpha; // d(theta) / dz
		float c = cos(theta), s = sin(theta);

		// transform normals
		shared_buffer[l_tid].normal = float3(c*n.x - s*n.y, s*n.x + c*n.y, v.y*dtheta*n.x - v.x*dtheta*n.y + n.z);

		// transform positions
		shared_buffer[l_tid].pos = float3(v.x*c - v.y*s, v.x*s + v.y*c, v.z);

		// Wait until all groups have finished
		GroupMemoryBarrierWithGroupSync();

		// Copy back to global memory
		g_buffer[g_tid] = shared_buffer[l_tid];
	}
}
