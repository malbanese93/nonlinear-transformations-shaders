// Specify which are the functions executed by GPU from outside
#pragma kernel Twist

// Same as in CPU
struct VertexData {
	float3 pos;
	float3 normal;
};

// Define the # of threads in a thread block
#define groupSize 512

// GLOBAL MEMORY buffer for all vertex data
RWStructuredBuffer<VertexData> g_buffer;

// SHARED MEMORY (inside each block) to accelerate computations
groupshared VertexData shared_buffer[groupSize];

// Parameters for transformation
float alpha;
uint vertexCount;

// Specify organization of thread block
// Since there is no implied geometry on the problem solved, we just consider
// each vertex in a single 1D list
// NB: the number of threads is highly dependent on the underlying architecture!
[numthreads(groupSize,1,1)]
void Twist (uint3 threadInGroupIndex : SV_GROUPTHREADID,
	        uint3 groupIndex         : SV_GROUPID)
{
	// Compute global and local thread ID
	// NB: all data stored in 1D so get first component only
	uint g_tid = (groupIndex * groupSize + threadInGroupIndex).x;
	uint l_tid = threadInGroupIndex.x;

	// Apply calculation only where the data actually are!
	if( g_tid < vertexCount ) {
		// First of all, let's copy data from global to shared memory
		shared_buffer[l_tid] = g_buffer[g_tid];

		// Wait until all copies have finished
		GroupMemoryBarrierWithGroupSync();

		// Apply calculation
		float3 v = shared_buffer[l_tid].pos;
		float3 n = shared_buffer[l_tid].normal;

		float theta = alpha * v.z;
		float dtheta = alpha; // d(theta) / dz
		float c = cos(theta), s = sin(theta);

		/*float x = v.x;
		float y = v.y;
		float z = v.z;
		float nx = n.x;
		float ny = n.y;
		float nz = n.z;*/

		// transform normals
		shared_buffer[l_tid].normal = n;//float3(c*nx - s*ny, s*nx + c*ny, y*dtheta*nx - x*dtheta*ny + nz);

		// transform positions
		shared_buffer[l_tid].pos = float3(v.x*c - v.y*s, v.x*s + v.y*c, v.z);

		// Wait until all groups have finished
		GroupMemoryBarrierWithGroupSync();

		// Copy back to global memory
		g_buffer[g_tid] = shared_buffer[l_tid];
	}
}
