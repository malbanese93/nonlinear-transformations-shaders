// Specify which are the functions executed by GPU from outside
#pragma kernel Twist

// Same as in CPU
struct VertexData {
	int3 pos;
	int3 normal;
};

// Define the # of threads in a thread block
#define groupSize 128

// GLOBAL MEMORY buffer for all vertex data
RWStructuredBuffer<VertexData> g_buffer;

// SHARED MEMORY (inside each block) to accelerate computations
groupshared VertexData shared_buffer[groupSize];

// Parameter for transformation
float alpha;

// Specify organization of thread block
// Since there is no implied geometry on the problem solved, we just consider
// each vertex in a single 1D list
// NB: the number of threads is highly dependent on the underlying architecture!
[numthreads(groupSize,1,1)]
void Twist (uint3 threadInGroupIndex : SV_GROUPTHREADID,
	        uint3 groupIndex         : SV_GROUPID)
{
	// Compute global and local thread ID
	// NB: all data stored in 1D so get first component only
	uint g_tid = (groupIndex * groupSize + threadInGroupIndex).x;
	uint l_tid = threadInGroupIndex.x;

	// First of all, let's copy data from global to shared memory
	shared_buffer[l_tid] = g_buffer[g_tid];

	GroupMemoryBarrierWithGroupSync();

    /*float theta = alpha * v.z;
	float dtheta = alpha; // d(theta) / dz
	float c = cos(theta), s = sin(theta);

	float x = v.x;
	float y = v.y;
	float z = v.z;

    vBuffer[id.x] = float3(x*c - y*s, x*s + y*c, z);

	// transform normals
	float3 n = nBuffer[id.x];

	float nx = n.x;
	float ny = n.y;
	float nz = n.z;

	nBuffer[id.x] = float3(c*nx - s*ny, s*nx + c*ny, y*dtheta*nx - x*dtheta*ny + nz);*/
}
